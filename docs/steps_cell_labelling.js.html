<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>steps/cell_labelling.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/LTLA/bakana" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AdtNormalizationState.html">AdtNormalizationState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#fetchNormalizedMatrix">fetchNormalizedMatrix</a></li><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#fetchSizeFactors">fetchSizeFactors</a></li></ul></li><li><a href="AdtPcaState.html">AdtPcaState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtPcaState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtPcaState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="AdtPcaState.html#fetchPCs">fetchPCs</a></li></ul></li><li><a href="AdtQualityControlState.html">AdtQualityControlState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#fetchDiscards">fetchDiscards</a></li><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#fetchFilters">fetchFilters</a></li><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#fetchMetrics">fetchMetrics</a></li><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="BatchCorrectionState.html">BatchCorrectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#fetchCorrected">fetchCorrected</a></li><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#fetchNumberOfCells">fetchNumberOfCells</a></li><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#fetchNumberOfDimensions">fetchNumberOfDimensions</a></li><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="CellFilteringState.html">CellFilteringState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CellFilteringState.html#applyFilter">applyFilter</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchDiscards">fetchDiscards</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchFilteredBlock">fetchFilteredBlock</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchFilteredMatrix">fetchFilteredMatrix</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#undoFilter">undoFilter</a></li></ul></li><li><a href="CellLabellingState.html">CellLabellingState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CellLabellingState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CellLabellingState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="CellLabellingState.html#fetchResults">fetchResults</a></li></ul></li><li><a href="ChooseClusteringState.html">ChooseClusteringState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#fetchClusters">fetchClusters</a></li><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="CombineEmbeddingsState.html">CombineEmbeddingsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#fetchCombined">fetchCombined</a></li><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#fetchNumberOfCells">fetchNumberOfCells</a></li><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#fetchNumberOfDimensions">fetchNumberOfDimensions</a></li><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="CrisprNormalizationState.html">CrisprNormalizationState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CrisprNormalizationState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CrisprNormalizationState.html#fetchNormalizedMatrix">fetchNormalizedMatrix</a></li><li data-type='method' style='display: none;'><a href="CrisprNormalizationState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="CrisprNormalizationState.html#fetchSizeFactors">fetchSizeFactors</a></li></ul></li><li><a href="CrisprPcaState.html">CrisprPcaState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CrisprPcaState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CrisprPcaState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="CrisprPcaState.html#fetchPCs">fetchPCs</a></li></ul></li><li><a href="CrisprQualityControlState.html">CrisprQualityControlState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CrisprQualityControlState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CrisprQualityControlState.html#fetchDiscards">fetchDiscards</a></li><li data-type='method' style='display: none;'><a href="CrisprQualityControlState.html#fetchFilters">fetchFilters</a></li><li data-type='method' style='display: none;'><a href="CrisprQualityControlState.html#fetchMetrics">fetchMetrics</a></li><li data-type='method' style='display: none;'><a href="CrisprQualityControlState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="CustomSelectionsState.html">CustomSelectionsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#.computeVersusCustom">computeVersusCustom</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#addSelection">addSelection</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#computeVersus">computeVersus</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchResults">fetchResults</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchSelectionIndices">fetchSelectionIndices</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchSelections">fetchSelections</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#removeSelection">removeSelection</a></li></ul></li><li><a href="FeatureSelectionState.html">FeatureSelectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#fetchResults">fetchResults</a></li><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#fetchSortedResiduals">fetchSortedResiduals</a></li></ul></li><li><a href="H5adDataset.html">H5adDataset</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5adDataset.html#.format">format</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#abbreviate">abbreviate</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#load">load</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setCountAssayName">setCountAssayName</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setFeatureTypeAdtName">setFeatureTypeAdtName</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setFeatureTypeColumnName">setFeatureTypeColumnName</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setFeatureTypeCrisprName">setFeatureTypeCrisprName</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setFeatureTypeRnaName">setFeatureTypeRnaName</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setPrimaryAdtFeatureIdColumn">setPrimaryAdtFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setPrimaryCrisprFeatureIdColumn">setPrimaryCrisprFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#setPrimaryRnaFeatureIdColumn">setPrimaryRnaFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="H5adDataset.html#summary">summary</a></li></ul></li><li><a href="InputsState.html">InputsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="InputsState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#enableDatasetCache">enableDatasetCache</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchBlock">fetchBlock</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchBlockLevels">fetchBlockLevels</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchCellAnnotations">fetchCellAnnotations</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchCountMatrix">fetchCountMatrix</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchDirectSubset">fetchDirectSubset</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchFeatureAnnotations">fetchFeatureAnnotations</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchRowIds">fetchRowIds</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#setDirectSubset">setDirectSubset</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#undoSubset">undoSubset</a></li></ul></li><li><a href="KmeansClusterState.html">KmeansClusterState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="KmeansClusterState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="KmeansClusterState.html#fetchClusters">fetchClusters</a></li><li data-type='method' style='display: none;'><a href="KmeansClusterState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="MarkerDetectionState.html">MarkerDetectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#.computeVersusCustom">computeVersusCustom</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#computeVersus">computeVersus</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#fetchResults">fetchResults</a></li></ul></li><li><a href="NeighborIndexState.html">NeighborIndexState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NeighborIndexState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="NeighborIndexState.html#fetchIndex">fetchIndex</a></li><li data-type='method' style='display: none;'><a href="NeighborIndexState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="RnaNormalizationState.html">RnaNormalizationState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RnaNormalizationState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="RnaNormalizationState.html#fetchNormalizedMatrix">fetchNormalizedMatrix</a></li><li data-type='method' style='display: none;'><a href="RnaNormalizationState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="RnaNormalizationState.html#fetchSizeFactors">fetchSizeFactors</a></li></ul></li><li><a href="RnaPcaState.html">RnaPcaState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RnaPcaState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="RnaPcaState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="RnaPcaState.html#fetchPCs">fetchPCs</a></li></ul></li><li><a href="RnaQualityControlState.html">RnaQualityControlState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RnaQualityControlState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="RnaQualityControlState.html#fetchDiscards">fetchDiscards</a></li><li data-type='method' style='display: none;'><a href="RnaQualityControlState.html#fetchFilters">fetchFilters</a></li><li data-type='method' style='display: none;'><a href="RnaQualityControlState.html#fetchMetrics">fetchMetrics</a></li><li data-type='method' style='display: none;'><a href="RnaQualityControlState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="SimpleFile.html">SimpleFile</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SimpleFile.html#buffer">buffer</a></li><li data-type='method' style='display: none;'><a href="SimpleFile.html#content">content</a></li><li data-type='method' style='display: none;'><a href="SimpleFile.html#name">name</a></li><li data-type='method' style='display: none;'><a href="SimpleFile.html#size">size</a></li></ul></li><li><a href="SnnGraphClusterState.html">SnnGraphClusterState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SnnGraphClusterState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="SnnGraphClusterState.html#fetchClusters">fetchClusters</a></li><li data-type='method' style='display: none;'><a href="SnnGraphClusterState.html#fetchParameters">fetchParameters</a></li></ul></li><li><a href="SummarizedExperimentDataset.html">SummarizedExperimentDataset</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#.format">format</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#abbreviate">abbreviate</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#load">load</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setAdtCountAssay">setAdtCountAssay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setAdtExperiment">setAdtExperiment</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setCrisprCountAssay">setCrisprCountAssay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setCrisprExperiment">setCrisprExperiment</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setPrimaryAdtFeatureIdColumn">setPrimaryAdtFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setPrimaryCrisprFeatureIdColumn">setPrimaryCrisprFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setPrimaryRnaFeatureIdColumn">setPrimaryRnaFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setRnaCountAssay">setRnaCountAssay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#setRnaExperiment">setRnaExperiment</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperimentDataset.html#summary">summary</a></li></ul></li><li><a href="TenxHdf5Dataset.html">TenxHdf5Dataset</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#.format">format</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#abbreviate">abbreviate</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#load">load</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setFeatureTypeAdtName">setFeatureTypeAdtName</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setFeatureTypeCrisprName">setFeatureTypeCrisprName</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setFeatureTypeRnaName">setFeatureTypeRnaName</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setPrimaryAdtFeatureIdColumn">setPrimaryAdtFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setPrimaryCrisprFeatureIdColumn">setPrimaryCrisprFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#setPrimaryRnaFeatureIdColumn">setPrimaryRnaFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxHdf5Dataset.html#summary">summary</a></li></ul></li><li><a href="TenxMatrixMarketDataset.html">TenxMatrixMarketDataset</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#.format">format</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#abbreviate">abbreviate</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#load">load</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setFeatureTypeAdtName">setFeatureTypeAdtName</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setFeatureTypeCrisprName">setFeatureTypeCrisprName</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setFeatureTypeRnaName">setFeatureTypeRnaName</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setPrimaryAdtFeatureIdColumn">setPrimaryAdtFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setPrimaryCrisprFeatureIdColumn">setPrimaryCrisprFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#setPrimaryRnaFeatureIdColumn">setPrimaryRnaFeatureIdColumn</a></li><li data-type='method' style='display: none;'><a href="TenxMatrixMarketDataset.html#summary">summary</a></li></ul></li><li><a href="TsneState.html">TsneState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TsneState.html#animate">animate</a></li><li data-type='method' style='display: none;'><a href="TsneState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="TsneState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="TsneState.html#fetchResults">fetchResults</a></li></ul></li><li><a href="UmapState.html">UmapState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="UmapState.html#animate">animate</a></li><li data-type='method' style='display: none;'><a href="UmapState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="UmapState.html#fetchParameters">fetchParameters</a></li><li data-type='method' style='display: none;'><a href="UmapState.html#fetchResults">fetchResults</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-DataFrame.html">external:DataFrame</a></li><li><a href="external-Dataset.html">external:Dataset</a></li><li><a href="external-ModelGeneVarResults.html">external:ModelGeneVarResults</a></li><li><a href="external-MultiMatrix.html">external:MultiMatrix</a></li><li><a href="external-PerCellAdtQcMetricsResults.html">external:PerCellAdtQcMetricsResults</a></li><li><a href="external-PerCellCrisprQcMetricsResults.html">external:PerCellCrisprQcMetricsResults</a></li><li><a href="external-PerCellRnaQcMetricsResults.html">external:PerCellRnaQcMetricsResults</a></li><li><a href="external-RunPCAResults.html">external:RunPCAResults</a></li><li><a href="external-ScoreMarkersResults.html">external:ScoreMarkersResults</a></li><li><a href="external-ScranMatrix.html">external:ScranMatrix</a></li><li><a href="external-SuggestAdtQcFiltersResults.html">external:SuggestAdtQcFiltersResults</a></li><li><a href="external-SuggestCrisprQcFiltersResults.html">external:SuggestCrisprQcFiltersResults</a></li><li><a href="external-SuggestRnaQcFiltersResults.html">external:SuggestRnaQcFiltersResults</a></li></ul><h3>Global</h3><ul><li><a href="global.html#analysisDefaults">analysisDefaults</a></li><li><a href="global.html#availableReaders">availableReaders</a></li><li><a href="global.html#callScran">callScran</a></li><li><a href="global.html#configureApproximateNeighbors">configureApproximateNeighbors</a></li><li><a href="global.html#configureBatchCorrection">configureBatchCorrection</a></li><li><a href="global.html#createAnalysis">createAnalysis</a></li><li><a href="global.html#createKanaFile">createKanaFile</a></li><li><a href="global.html#formatMarkerResults">formatMarkerResults</a></li><li><a href="global.html#freeAnalysis">freeAnalysis</a></li><li><a href="global.html#guessApproximateNeighborsConfig">guessApproximateNeighborsConfig</a></li><li><a href="global.html#guessBatchCorrectionConfig">guessBatchCorrectionConfig</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#kanaFormatVersion">kanaFormatVersion</a></li><li><a href="global.html#loadAnalysis">loadAnalysis</a></li><li><a href="global.html#parseKanaFile">parseKanaFile</a></li><li><a href="global.html#promoteToNumber">promoteToNumber</a></li><li><a href="global.html#readLines2">readLines2</a></li><li><a href="global.html#readTable2">readTable2</a></li><li><a href="global.html#retrieveParameters">retrieveParameters</a></li><li><a href="global.html#runAnalysis">runAnalysis</a></li><li><a href="global.html#saveAnalysis">saveAnalysis</a></li><li><a href="global.html#setCellLabellingDownload">setCellLabellingDownload</a></li><li><a href="global.html#setCreateLink">setCreateLink</a></li><li><a href="global.html#setResolveLink">setResolveLink</a></li><li><a href="global.html#setVisualizationAnimate">setVisualizationAnimate</a></li><li><a href="global.html#subsetInputs">subsetInputs</a></li><li><a href="global.html#summarizeArray">summarizeArray</a></li><li><a href="global.html#terminate">terminate</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">steps/cell_labelling.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as scran from "scran.js";
import * as utils from "./utils/general.js";
import * as rutils from "../readers/index.js";
import * as inputs_module from "./inputs.js";
import * as markers_module from "./marker_detection.js";

var downloadFun = async (url) => {
    let resp = await fetch(url);
    if (!resp.ok) {
        throw new Error("failed to fetch content at " + url + "(" + resp.status + ")");
    }
    return new Uint8Array(await resp.arrayBuffer());
};

const hs_base = "https://github.com/clusterfork/singlepp-references/releases/download/hs-latest";
const mm_base = "https://github.com/clusterfork/singlepp-references/releases/download/mm-latest";

// Loaded references are constant, independent of the dataset;
// so we can keep these as globals for re-use across States.
const hs_loaded = {};
const mm_loaded = {};

/**
 * Cell labelling involves assigning cell type labels to clusters using the [**SingleR** algorithm](https://github.com/LTLA/CppSingleR),
 * based on [pre-formatted reference expression profiles](https://github.com/clusterfork/singlepp-references).
 * This wraps [`labelCells`](https://jkanche.com/scran.js/global.html#labelCells)
 * and related functions from [**scran.js**](https://github.com/jkanche/scran.js).
 *
 * In theory, we could do this at the single-cell level, but we use clusters instead to expedite the computation and simplify interpretation.
 * If multiple references are requested, we will use each for assignment before attempting to choose the best label for each cluster across references.
 *
 * Methods not documented here are not part of the stable API and should not be used by applications.
 * @hideconstructor
 */
export class CellLabellingState {
    #inputs;
    #markers;
    #parameters;
    #cache;

    #hs_built;
    #mm_built;

    constructor(inputs, markers, parameters = null, cache = null) {
        if (!(inputs instanceof inputs_module.InputsState)) {
            throw new Error("'inputs' should be a State object from './inputs.js'");
        }
        this.#inputs = inputs;

        if (!(markers instanceof markers_module.MarkerDetectionState)) {
            throw new Error("'markers' should be a State object from './marker_detection.js'");
        }
        this.#markers = markers;

        this.#parameters = (parameters === null ? {} : parameters);
        this.#cache = (cache === null ? {} : cache);
        this.changed = false;

        this.#hs_built = {};
        this.#mm_built = {};
    }

    free() {
        utils.freeCache(this.#cache.buffer);
        for (const [k, v] of Object.entries(this.#hs_built)) {
            v.raw.free();
        }
        for (const [k, v] of Object.entries(this.#mm_built)) {
            v.raw.free();
        }
    }

    /***************************
     ******** Getters **********
     ***************************/

    valid() {
        let mat = this.#inputs.fetchCountMatrix();
        return mat.has("RNA");
    }

    /**
     * @return {object} Object containing the parameters.
     */
    fetchParameters() {
        // Avoid any pass-by-reference activity.
        let out = { ...this.#parameters };
        for (const key of [ "human_references", "mouse_references" ]) {
            out[key] = out[key].slice();
        }
        return out;
    }

    /**
     * @return {object} An object containing:
     *
     * - `per_reference`: an object where keys are the reference names and the values are arrays of strings.
     *   Each array is of length equal to the number of clusters and contains the cell type classification for each cluster.
     * - `integrated`: an array of length equal to the number of clusters.
     *   Each element is a string specifying the name of the reference with the best label for each cluster.
     *   Only available if multiple references are requested.
     *
     * This is available after running {@linkcode CellLabellingState#compute compute}.
     *
     * @async
     */
    async fetchResults() {
        // No real need to clone these, they're string arrays
        // so they can't be transferred anyway.
        let perref = {};
        for (const [key, val] of Object.entries(this.#cache.results)) {
            perref[key] = await val;
        }

        let output = { "per_reference": perref };
        if ("integrated_results" in this.#cache) {
            output.integrated = await this.#cache.integrated_results;
        }

        return output;
    }

    /***************************
     ******** Compute **********
     ***************************/

    async #build_reference(name, species, rebuild) {
        let base;
        let all_loaded;
        let all_built;
        if (species == "human") {
            base = hs_base;
            all_loaded = hs_loaded;
            all_built = this.#hs_built;
        } else {
            base = mm_base;
            all_loaded = mm_loaded;
            all_built = this.#mm_built;
        }

        if (!(name in all_loaded)) {
            let suffixes = [ 
                "genes.csv.gz",
                "labels_fine.csv.gz",
                "label_names_fine.csv.gz",
                "markers_fine.gmt.gz",
                "matrix.csv.gz"
            ];

            let contents = await Promise.all(
                suffixes.map(
                    async suffix => {
                        let full = name + "_" + suffix;
                        let b = await downloadFun(base + "/" + full);
                        return new rutils.SimpleFile(b, { name: full })
                    }
                )
            );

            let loaded;
            try {
                loaded = scran.loadLabelledReferenceFromBuffers(
                    contents[4].buffer(), // rank matrix
                    contents[3].buffer(), // markers
                    contents[1].buffer()  // label per sample
                );

                let gene_lines = await rutils.readLines2(contents[0].content(), { compression: "gz" }); // gene names
                let ensembl = [];
                let symbol = [];
                gene_lines.forEach(x => {
                    let fields = x.split(",");
                    ensembl.push(fields[0]);
                    symbol.push(fields[1]);
                });

                let labels = await rutils.readLines2(contents[2].content(), { compression: "gz" }); // full label names
                all_loaded[name] = { 
                    "raw": loaded, 
                    "genes": {
                        "ensembl": ensembl,
                        "symbol": symbol
                    },
                    "labels": labels
                };

            } catch (e) {
                utils.freeCache(loaded);
                throw e;
            }
        }

        if (!(name in all_built) || rebuild) {
            let built;
            try {
                if (name in all_built) {
                    utils.freeCache(all_built[name].raw);
                }

                let current = all_loaded[name];
                let loaded = current.raw;

                let chosen_ids;
                if (this.#cache.feature_details.type === "ensembl") {
                    chosen_ids = current.genes.ensembl;
                } else {
                    chosen_ids = current.genes.symbol;
                }

                let built = scran.buildLabelledReference(this.#cache.features, loaded, chosen_ids); 
                all_built[name] = {
                    "features": chosen_ids,
                    "raw": built
                };

            } catch (e) {
                utils.freeCache(built);
                throw e;
            }
        }

        return {
            "loaded": all_loaded[name],
            "built": all_built[name]
        };
    }

    /**
     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.
     * Each argument is taken from the property of the same name in the `cell_labelling` property of the `parameters` of {@linkcode runAnalysis}.
     *
     * @param {Array} mouse_references - Array of strings specifying the names of the reference datasets for mouse datasets, e.g., `"ImmGen"`.
     * @param {Array} human_references - Array of strings specifying the names of the reference datasets for human datasets, e.g., `"BlueprintEncode"`.
     *
     * @return The object is updated with the new results.
     */
    compute(human_references, mouse_references) {
        this.changed = false;

        if (!this.#inputs.changed &amp;&amp; 
            !this.#markers.changed &amp;&amp;
            compare_arrays(human_references, this.#parameters.human_references) &amp;&amp;
            compare_arrays(mouse_references, this.#parameters.mouse_references)) 
        {
            return new Promise(resolve => resolve(null));
        }

        let promises = [];
        if (this.valid()) {
            if (this.#inputs.changed || !("features" in this.#cache)) {
                let feat_out = choose_features(this.#inputs);
                this.#cache.features = feat_out.features;
                this.#cache.feature_details = feat_out.details;
            }

            // null species results in empty 'valid' and no further ops downstream.
            let species = (this.#cache.feature_details !== null ? this.#cache.feature_details.species : null);

            // Take ownership to avoid pass-by-reference shenanigans.
            human_references = human_references.slice();
            mouse_references = mouse_references.slice();

            // Fetching all of the references. This is effectively a no-op
            // if the inputs have not changed, so we do it to fill up 'valid'.
            let valid = {};
            if (species == "human") {
                for (const ref of human_references) {
                    valid[ref] = this.#build_reference(ref, "human", this.#inputs.changed);
                }
            } else if (species == "mouse") {
                for (const ref of mouse_references) {
                    valid[ref] = this.#build_reference(ref, "mouse", this.#inputs.changed);
                }
            }

            // Creating a column-major array of mean vectors for each cluster.
            let cluster_means = this.#cache.buffer;
            let ngenes;
            let ngroups;
            if (this.#cache.features !== null) {
                ngenes = this.#cache.features.length;
                let marker_results = this.#markers.fetchResults()["RNA"];
                ngroups = marker_results.numberOfGroups();

                if (this.#markers.changed || typeof cluster_means === "undefined") {
                    cluster_means = utils.allocateCachedArray(ngroups * ngenes, "Float64Array", this.#cache);

                    for (var g = 0; g &lt; ngroups; g++) {
                        let means = marker_results.means(g, { copy: false }); // Warning: direct view in wasm space - be careful.
                        let cluster_array = cluster_means.array();
                        cluster_array.set(means, g * ngenes);
                    }
                }
            }

            // Running classifications on the cluster means. Note that compute() itself
            // cannot be async, as we need to make sure 'changed' is set and available for
            // downstream steps; hence the explicit then().
            this.#cache.results = {};
            for (const [key, val] of Object.entries(valid)) {
                let p = val.then(ref => {
                    let output = scran.labelCells(cluster_means, ref.built.raw, { numberOfFeatures: ngenes, numberOfCells: ngroups });
                    let labels = [];
                    for (const o of output) {
                        labels.push(ref.loaded.labels[o]);
                    }
                    return labels;
                });
                this.#cache.results[key] = p;
                promises.push(p);
            }

            // Performing additional integration, if necessary. We don't really 
            // need this if there's only one reference.
            let used_refs = Object.keys(valid);
            if (used_refs.length > 1) {
                if (this.#inputs.changed || !compare_arrays(used_refs, this.#cache.used) || !("integrated" in this.#cache)) {
                    let used_vals = Object.values(valid);

                    this.#cache.integrated = Promise.all(used_vals)
                        .then(arr => {
                            let loaded = arr.map(x => x.loaded.raw);
                            let feats = arr.map(x => x.built.features);
                            let built = arr.map(x => x.built.raw);
                            return scran.integrateLabelledReferences(this.#cache.features, loaded, feats, built);
                        }
                    );
                }

                let p = this.#cache.integrated
                    .then(async (integrated) => {
                        let results = [];
                        for (const key of used_refs) {
                            results.push(await this.#cache.results[key]);
                        }

                        let out = scran.integrateCellLabels(cluster_means, results, integrated, { numberOfFeatures: ngenes, numberOfCells: ngroups });
                        let as_names = [];
                        out.forEach(i => {
                            as_names.push(used_refs[i]);
                        });
                        return as_names;
                    }
                );
                this.#cache.integrated_results = p;
                promises.push(p);
            } else {
                delete this.#cache.integrated_results;
            }

            this.#cache.used = used_refs;
            this.changed = true;
        }

        this.#parameters.human_references = human_references;
        this.#parameters.mouse_references = mouse_references;

        return Promise.all(promises).then(x => null);
    }

    /*************************
     ******** Saving *********
     *************************/

    async serialize(handle) {
        let ghandle = handle.createGroup("cell_labelling");
        
        {
            let phandle = ghandle.createGroup("parameters");
            phandle.writeDataSet("mouse_references", "String", null, this.#parameters.mouse_references);
            phandle.writeDataSet("human_references", "String", null, this.#parameters.human_references);
        }

        {
            let rhandle = ghandle.createGroup("results");
            if (this.valid()) {
                let res = await this.fetchResults();

                let perhandle = rhandle.createGroup("per_reference");
                for (const [key, val] of Object.entries(res.per_reference)) {
                    perhandle.writeDataSet(key, "String", null, val);
                }

                if ("integrated" in res) {
                    rhandle.writeDataSet("integrated", "String", null, res.integrated);
                }
            }
        }

        return;
    }
}

/**************************
 ******* Internals ********
 **************************/

// Try to figure out the best feature identifiers to use,
// based on the highest confidence annotation.
function choose_features(inputs) {
    let genes = inputs.fetchFeatureAnnotations()["RNA"];

    let best_feature = null;
    let best = null;
    for (const key of genes.columnNames()) {
        let col = genes.column(key);
        let val = scran.guessFeatures(col);
        if (best === null) {
            best_feature = key;
            best = val;
        } else if (val.confidence > best.confidence) {
            best_feature = key;
            best = val;
        }
    }

    return { 
        details: best,
        features: best_feature == null ? null : genes.column(best_feature)
    };
}

function compare_arrays(x, y) {
    if (typeof x === "undefined" || typeof y === "undefined") {
        return false;
    }
    if (x.length != y.length) {
        return false;
    }
    for (var i = 0; i &lt; x.length; i++) {
        if (x[i] != y[i]) {
            return false;
        }
    }
    return true;
}

/**************************
 ******** Loading *********
 **************************/

export function unserialize(handle, inputs, markers) {
    let parameters =  {
        mouse_references: [],
        human_references: []
    };
    let cache = { results: {} };

    // Protect against old analysis states that don't have cell_labelling.
    if ("cell_labelling" in handle.children) {
        let ghandle = handle.open("cell_labelling");
        
        {
            let phandle = ghandle.open("parameters");
            parameters.mouse_references = phandle.open("mouse_references", { load: true }).values;
            parameters.human_references = phandle.open("human_references", { load: true }).values;
        }

        {
            let rhandle = ghandle.open("results");

            if ("per_reference" in rhandle.children) {
                let perhandle = rhandle.open("per_reference");
                for (const key of Object.keys(perhandle.children)) {
                    cache.results[key] = perhandle.open(key, { load: true }).values;
                }
                if ("integrated" in rhandle.children) {
                    cache.integrated_results = rhandle.open("integrated", { load: true }).values;
                }
            }
        }
    }

    return new CellLabellingState(inputs, markers, parameters, cache);
}

/**************************
 ******** Setters *********
 **************************/

/**
 * Specify a function to download references for the cell labelling step.
 *
 * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.
 * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.
 *
 * @return `fun` is set as the global downloader for this step. 
 * The _previous_ value of the downloader is returned.
 */
export function setCellLabellingDownload(fun) {
    let previous = downloadFun;
    downloadFun = fun;
    return previous;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Tue Dec 27 2022 08:38:55 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
