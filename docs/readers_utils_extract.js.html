<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>readers/utils/extract.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/LTLA/bakana" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AdtNormalizationState.html">AdtNormalizationState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#fetchExpression">fetchExpression</a></li><li data-type='method' style='display: none;'><a href="AdtNormalizationState.html#summary">summary</a></li></ul></li><li><a href="AdtPcaState.html">AdtPcaState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtPcaState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtPcaState.html#summary">summary</a></li></ul></li><li><a href="AdtQualityControlState.html">AdtQualityControlState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="AdtQualityControlState.html#summary">summary</a></li></ul></li><li><a href="BatchCorrectionState.html">BatchCorrectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BatchCorrectionState.html#compute">compute</a></li></ul></li><li><a href="CellFilteringState.html">CellFilteringState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CellFilteringState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchFilteredAnnotations">fetchFilteredAnnotations</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#fetchFilteredBlock">fetchFilteredBlock</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#summary">summary</a></li><li data-type='method' style='display: none;'><a href="CellFilteringState.html#undoFiltering">undoFiltering</a></li></ul></li><li><a href="CellLabellingState.html">CellLabellingState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CellLabellingState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CellLabellingState.html#summary">summary</a></li></ul></li><li><a href="ChooseClusteringState.html">ChooseClusteringState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#fetchClusterIndices">fetchClusterIndices</a></li><li data-type='method' style='display: none;'><a href="ChooseClusteringState.html#summary">summary</a></li></ul></li><li><a href="CombineEmbeddingsState.html">CombineEmbeddingsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CombineEmbeddingsState.html#compute">compute</a></li></ul></li><li><a href="CustomSelectionsState.html">CustomSelectionsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#addSelection">addSelection</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchResults">fetchResults</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchSelectionIndices">fetchSelectionIndices</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#fetchSelections">fetchSelections</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#removeSelection">removeSelection</a></li><li data-type='method' style='display: none;'><a href="CustomSelectionsState.html#summary">summary</a></li></ul></li><li><a href="FeatureSelectionState.html">FeatureSelectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="FeatureSelectionState.html#summary">summary</a></li></ul></li><li><a href="InputsState.html">InputsState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="InputsState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#fetchAnnotations">fetchAnnotations</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#setDirectSubset">setDirectSubset</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#summary">summary</a></li><li data-type='method' style='display: none;'><a href="InputsState.html#undoSubset">undoSubset</a></li></ul></li><li><a href="KmeansClusterState.html">KmeansClusterState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="KmeansClusterState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="KmeansClusterState.html#summary">summary</a></li></ul></li><li><a href="MarkerDetectionState.html">MarkerDetectionState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#fetchGroupResults">fetchGroupResults</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#numberOfGroups">numberOfGroups</a></li><li data-type='method' style='display: none;'><a href="MarkerDetectionState.html#summary">summary</a></li></ul></li><li><a href="NeighborIndexState.html">NeighborIndexState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NeighborIndexState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="NeighborIndexState.html#summary">summary</a></li></ul></li><li><a href="NormalizationState.html">NormalizationState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NormalizationState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="NormalizationState.html#fetchExpression">fetchExpression</a></li><li data-type='method' style='display: none;'><a href="NormalizationState.html#summary">summary</a></li></ul></li><li><a href="PcaState.html">PcaState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PcaState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="PcaState.html#summary">summary</a></li></ul></li><li><a href="QualityControlState.html">QualityControlState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="QualityControlState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="QualityControlState.html#summary">summary</a></li></ul></li><li><a href="SnnGraphClusterState.html">SnnGraphClusterState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SnnGraphClusterState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="SnnGraphClusterState.html#summary">summary</a></li></ul></li><li><a href="TsneState.html">TsneState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TsneState.html#animate">animate</a></li><li data-type='method' style='display: none;'><a href="TsneState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="TsneState.html#summary">summary</a></li></ul></li><li><a href="UmapState.html">UmapState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="UmapState.html#animate">animate</a></li><li data-type='method' style='display: none;'><a href="UmapState.html#compute">compute</a></li><li data-type='method' style='display: none;'><a href="UmapState.html#summary">summary</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#analysisDefaults">analysisDefaults</a></li><li><a href="global.html#availableReaders">availableReaders</a></li><li><a href="global.html#callScran">callScran</a></li><li><a href="global.html#configureApproximateNeighbors">configureApproximateNeighbors</a></li><li><a href="global.html#configureBatchCorrection">configureBatchCorrection</a></li><li><a href="global.html#createAnalysis">createAnalysis</a></li><li><a href="global.html#createKanaFile">createKanaFile</a></li><li><a href="global.html#createKanaFileInternal">createKanaFileInternal</a></li><li><a href="global.html#createTsneWorker">createTsneWorker</a></li><li><a href="global.html#freeAnalysis">freeAnalysis</a></li><li><a href="global.html#guessApproximateNeighborsConfig">guessApproximateNeighborsConfig</a></li><li><a href="global.html#guessBatchCorrectionConfig">guessBatchCorrectionConfig</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#kanaFormatVersion">kanaFormatVersion</a></li><li><a href="global.html#loadAnalysis">loadAnalysis</a></li><li><a href="global.html#parseKanaFile">parseKanaFile</a></li><li><a href="global.html#promoteToNumber">promoteToNumber</a></li><li><a href="global.html#readLines">readLines</a></li><li><a href="global.html#readTable">readTable</a></li><li><a href="global.html#removeHDF5File">removeHDF5File</a></li><li><a href="global.html#retrieveParameters">retrieveParameters</a></li><li><a href="global.html#runAnalysis">runAnalysis</a></li><li><a href="global.html#saveAnalysis">saveAnalysis</a></li><li><a href="global.html#setCellLabellingDownload">setCellLabellingDownload</a></li><li><a href="global.html#setCreateLink">setCreateLink</a></li><li><a href="global.html#setResolveLink">setResolveLink</a></li><li><a href="global.html#setVisualizationAnimate">setVisualizationAnimate</a></li><li><a href="global.html#subsetInputs">subsetInputs</a></li><li><a href="global.html#summarizeArray">summarizeArray</a></li><li><a href="global.html#terminate">terminate</a></li><li><a href="global.html#unpackText">unpackText</a></li><li><a href="global.html#validateAnnotations">validateAnnotations</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">readers/utils/extract.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as pako from "pako";
import ppp from "papaparse";
import * as afile from "../../abstract/file.js";

export function extractHDF5Strings(handle, name) {
    if (!(name in handle.children)) {
        return null;
    }

    if (handle.children[name] !== "DataSet") {
        return null;
    }

    let content = handle.open(name);
    if (content.type !== "String") {
        return null;
    }

    return content.load();
}

/**
 * Summarize an array, typically corresponding to a single column of per-cell annotation.
 * This can be used as part of a preflight response in a Reader.
 *
 * @param {Array|TypedArray} array - Per-cell annotation array of length equal to the number of cells for a given matrix.
 * An Array is treated as categorical data and should contain strings, while TypedArrays are treated as continuous data.
 * @param {object} [options] - Optional parameters.
 * @param {number} [options.limit=50] - Maximum number of unique values to report for categorical `x`.
 *
 * @return {object} Object containing `type`, a string indicating whether `array` was categorical or continuous.
 *
 * If `"categorical"`, the object will contain `values`, an array of unique values up to the length specified by `limit`.
 * It will also contain `truncated`, a boolean indicating whether the actual number of unique values exceeds `limit`.
 *
 * If `"continuous"`, the object will contain the numbers `min` and `max` specifying the minimum and maximum value in `x`, respectively.
 * `min` or `max` may be negative or positive infinity, respectively, if there is no bound on one or both ends.
 * If `min > max`, all values in `array` are `NaN`s such that no bound can be found.
 */
export function summarizeArray(array, { limit = 50 } = {}) {
    if (array instanceof Array) {
        let chosen = Array.from(new Set(array));
        chosen.sort();
        let truncated = false;
        if (chosen.length > limit) {
            chosen = chosen.slice(0, limit);
            truncated = true;
        }
        return {
            "type": "categorical",
            "values": chosen,
            "truncated": truncated
        };
    } else {
        let min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;
        array.forEach(x => {
            if (x &lt; min) {
                min = x;
            }
            if (x > max) {
                max = x;
            }
        });

        return { 
            "type": "continuous",
            "min": min, 
            "max": max 
        };
    }
}

/**
 * Unpack a buffer to text, possibly with decompression.
 *
 * @param {Uint8Array} buffer - Contents to be unpacked.
 * @param {object} [options] - Optional parameters.
 * @param {?string} [options.compression] - Compression mode used for `buffer`.
 * This can be `"none"` or `"gz"`, with `null` performing automatic detection based on the magic words.
 *
 * @return {string} Text encoded by `buffer`.
 */
export function unpackText(buffer, { compression = null } = {}) {
    let txt = buffer;
    
    // Compare against magic words for auto-detection.
    if (compression === null) {
        if (buffer.length >= 3 &amp;&amp; buffer[0] == 0x1F &amp;&amp; buffer[1] == 0x8B &amp;&amp; buffer[2] == 0x08) {
            compression = 'gz';
        }
    }

    if (compression === "gz") {
        txt = pako.ungzip(buffer);
    }
    
    const dec = new TextDecoder();
    return dec.decode(txt);
}

/**
 * Read lines of text from a buffer, possibly with decompression.
 *
 * @param {Uint8Array} buffer - Content to be read.
 * @param {object} [options] - Optional parameters.
 * @param {?string} [options.compression] - See {@linkcode unpackText} for details.
 *
 * @return {Array} Array of strings where each entry contains a line in `buffer`.
 * The newline itself is not included in each string. 
 * A trailing newline at the end of each file is removed.
 */
export function readLines(buffer, { compression = null } = {}) {
    let decoded = unpackText(buffer, { compression: compression });
    let lines = decoded.split("\n");
    if (lines.length > 0 &amp;&amp; lines[lines.length - 1] == "") { // ignoring the trailing newline.
        lines.pop();
    }
    return lines;    
}

/**
 * Read a delimiter-separated table from a buffer, possibly with decompression.
 *
 * @param {Uint8Array|ArrayBuffer|string} content - Content to be read as an ArrayBuffer or Uint8Array.
 * For Node.js, this may be also a string containing a path to a file.
 * @param {object} [options] - Optional parameters.
 * @param {?string} [options.compression] - See {@linkcode unpackText} for details.
 * @param {string} [options.delim] - Delimiter between fields.
 * @param {boolean} [options.firstOnly] - Whether to only read the first line, presumably containing the header.
 *
 * @return {Array} Array of arrays where each entry corresponds to a line in `buffer` and contains the `delim`-separated fields.
 * If `firstOnly = true`, the output array only contains one element corresponding to the contents of the first line.
 */
export function readTable(content, { compression = null, delim = "\t", firstOnly = false } = {}) {
    let buffer;
    if (content instanceof Uint8Array) {
        buffer = content;
    } else {
        // This clause handles file paths on Node.js; for browsers, it should
        // not be called as 'content' can only be a Uint8Array or ArrayBuffer.
        if (!(content instanceof ArrayBuffer)) {
            let loaded = new afile.LoadedFile(content);
            content = loaded.buffer();
        }
        buffer = new Uint8Array(content);
    }

    let decoded = unpackText(buffer, { compression: compression });
    let res = ppp.parse(decoded, { delimiter: delim, preview: (firstOnly ? 1 : 0) });

    // Handle terminating newlines.
    let last = res.data[res.data.length - 1];
    if (last.length === 1 &amp;&amp; last[0] === "") {
        res.data.pop();
    }

    return res.data;
}

/**
 * Detect if an array contains only stringified numbers and, if so, convert it into a TypedArray.
 * Conversion will still be performed for non-number strings corresponding to missing values or explicit not-a-number entries.
 *
 * @param {Array} x Array of strings, usually corresponding to a column in a table read by {@linkcode readDSVFromBuffer}.
 *
 * @return {?Float64Array} A Float64Array is returned if `x` contains stringified numbers.
 * Otherwise, `null` is returned if the conversion could not be performed.
 */
export function promoteToNumber(x) {
    let as_num = new Float64Array(x.length);

    for (const [i, v] of Object.entries(x)) {
        // See discussion at https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number.
        let opt1 = Number(v);
        let opt2 = parseFloat(v);
        if (!isNaN(opt1) &amp;&amp; !isNaN(opt2)) {
            as_num[i] = opt1;
        } else if (v === "" || v === "NA" || v == "na" || v == "NaN" || v == "nan") {
            as_num[i] = NaN;
        } else if (v == "Inf" || v == "inf") {
            as_num[i] = Number.POSITIVE_INFINITY;
        } else if (v == "-Inf" || v == "-inf") {
            as_num[i] = Number.NEGATIVE_INFINITY;
        } else {
            return null;
        }
    }

    return as_num;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sat Jul 30 2022 20:04:52 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
